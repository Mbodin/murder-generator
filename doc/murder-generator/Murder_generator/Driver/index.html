<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Driver (murder-generator.Murder_generator.Driver)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">murder-generator</a> &#x00BB; <a href="../index.html">Murder_generator</a> &#x00BB; Driver</nav><h1>Module <code>Murder_generator.Driver</code></h1></header><aside><p>Module Driver. This module treats the abstract syntax tree produced by the Parser module into something that can be used later on.</p></aside><dl><dt class="spec value" id="val-parse_lexbuf"><a href="#val-parse_lexbuf" class="anchor"></a><code><span class="keyword">val</span> parse_lexbuf : string <span>&#45;&gt;</span> Stdlib.Lexing.lexbuf <span>&#45;&gt;</span> <span><a href="../Ast/index.html#type-declaration">Ast.declaration</a> list</span></code></dt><dd><p>From the file name and the lexing buffer, calls the parser.</p></dd></dl><dl><dt class="spec value" id="val-parse_relation"><a href="#val-parse_relation" class="anchor"></a><code><span class="keyword">val</span> parse_relation : string <span>&#45;&gt;</span> <a href="../Relation/index.html#type-t">Relation.t</a></code></dt><dd><p>Parses a relation obtained through <code>Relation.to_string</code>.</p></dd></dl><dl><dt class="spec type" id="type-intermediary"><a href="#type-intermediary" class="anchor"></a><code><span class="keyword">type</span> intermediary</code></dt><dd><p>A type to store intermediate informations about parsing.</p></dd></dl><dl><dt class="spec exception" id="exception-UnexpectedCommandInBlock"><a href="#exception-UnexpectedCommandInBlock" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">UnexpectedCommandInBlock</span> <span class="keyword">of</span> string * string</code></dt><dd><p>States that the block named as the first string has an invalid command in its block, which is described by the second string.</p></dd></dl><dl><dt class="spec exception" id="exception-DefinedTwice"><a href="#exception-DefinedTwice" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">DefinedTwice</span> <span class="keyword">of</span> string * string * string</code></dt><dd><p>An error indicating that something of kind described by the first string has been defined twice, the second string being its name, and the third describe its enclosing block.</p></dd></dl><dl><dt class="spec exception" id="exception-Undeclared"><a href="#exception-Undeclared" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Undeclared</span> <span class="keyword">of</span> string * string * string</code></dt><dd><p>An error indicating that something of kind described by the first string has been used without being declared, the second string being its name, and the third describe its enclosing block.</p></dd></dl><dl><dt class="spec exception" id="exception-CircularDependency"><a href="#exception-CircularDependency" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">CircularDependency</span> <span class="keyword">of</span> string * string</code></dt><dd><p>An error indicating that there is a loop definitions. The first argument is the definition kind, the second its name.</p></dd></dl><dl><dt class="spec exception" id="exception-SelfRelation"><a href="#exception-SelfRelation" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">SelfRelation</span> <span class="keyword">of</span> string * string</code></dt><dd><p>An error indicating that a player has been associated a relation to itself in the given element.</p></dd></dl><dl><dt class="spec exception" id="exception-TranslationError"><a href="#exception-TranslationError" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">TranslationError</span> <span class="keyword">of</span> string * string * <a href="../Ast/index.html#type-translation">Ast.translation</a></code></dt><dd><p>An unexpected translation item has been given in an element of the kind described by the first argument, whose name is the second argument.</p></dd></dl><dl><dt class="spec exception" id="exception-VacuumElement"><a href="#exception-VacuumElement" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">VacuumElement</span> <span class="keyword">of</span> string</code></dt><dd><p>The given element can’t be applied (typically because some constraints are incompatible).</p></dd></dl><dl><dt class="spec exception" id="exception-UnsatisfyableEventSequence"><a href="#exception-UnsatisfyableEventSequence" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">UnsatisfyableEventSequence</span> <span class="keyword">of</span> string</code></dt><dd><p>If a sequence of event is not satisfyable in an element, report the element. A sequence of event may not be satisfyable if for instance an event prevents an event of a given kind to appear after it, but that this precise one actually appears in the event.</p></dd></dl><dl><dt class="spec value" id="val-prepare_declarations"><a href="#val-prepare_declarations" class="anchor"></a><code><span class="keyword">val</span> prepare_declarations : <a href="index.html#type-intermediary">intermediary</a> <span>&#45;&gt;</span> <span><a href="../Ast/index.html#type-declaration">Ast.declaration</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-intermediary">intermediary</a></code></dt><dd><p>Treating the data sent from the parser is done in two phases. The first phase is to assimilate each globally declared names into identifiers. It expects the previously computed <code>intermediary</code> type. This function might throw <code>UnexpectedCommandInBlock</code> or <code>DefinedTwice</code>.</p></dd></dl><dl><dt class="spec value" id="val-empty_intermediary"><a href="#val-empty_intermediary" class="anchor"></a><code><span class="keyword">val</span> empty_intermediary : <a href="index.html#type-intermediary">intermediary</a></code></dt><dd><p>An initial empty <code>intermediary</code> element.</p></dd></dl><dl><dt class="spec value" id="val-is_intermediary_final"><a href="#val-is_intermediary_final" class="anchor"></a><code><span class="keyword">val</span> is_intermediary_final : <a href="index.html#type-intermediary">intermediary</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>States whether the <code>intermediary</code> type is waiting for other definitions to be complete. This function is usually called once each file have been loaded and merged into an <code>intermediate</code>: if this function then returns <code>false</code>, an error has been made somewhere.</p></dd></dl><dl><dt class="spec value" id="val-categories_to_be_defined"><a href="#val-categories_to_be_defined" class="anchor"></a><code><span class="keyword">val</span> categories_to_be_defined : <a href="index.html#type-intermediary">intermediary</a> <span>&#45;&gt;</span> <span>string Libutils.PSet.t</span></code></dt><dd><p>Return a set of missing categories.</p></dd></dl><dl><dt class="spec value" id="val-events_to_be_defined"><a href="#val-events_to_be_defined" class="anchor"></a><code><span class="keyword">val</span> events_to_be_defined : <a href="index.html#type-intermediary">intermediary</a> <span>&#45;&gt;</span> <span>string Libutils.PSet.t</span></code></dt><dd><p>Return a set of missing events.</p></dd></dl><dl><dt class="spec value" id="val-attributes_to_be_defined"><a href="#val-attributes_to_be_defined" class="anchor"></a><code><span class="keyword">val</span> attributes_to_be_defined : <a href="index.html#type-intermediary">intermediary</a> <span>&#45;&gt;</span> <span>string Libutils.PSet.t</span> * <span>string Libutils.PSet.t</span></code></dt><dd><p>Return a set of missing attributes and contacts.</p></dd></dl><dl><dt class="spec value" id="val-constructors_to_be_defined"><a href="#val-constructors_to_be_defined" class="anchor"></a><code><span class="keyword">val</span> constructors_to_be_defined : <a href="index.html#type-intermediary">intermediary</a> <span>&#45;&gt;</span> <span><span>(string * string)</span> Libutils.PSet.t</span> * <span><span>(string * string)</span> Libutils.PSet.t</span></code></dt><dd><p>Return a set of missing constructors for attributes and contacts. The first element of each couple is the attribute name, then the constructor name.</p></dd></dl><dl><dt class="spec value" id="val-tags_to_be_defined"><a href="#val-tags_to_be_defined" class="anchor"></a><code><span class="keyword">val</span> tags_to_be_defined : <a href="index.html#type-intermediary">intermediary</a> <span>&#45;&gt;</span> <span><span>(string * string)</span> Libutils.PSet.t</span></code></dt><dd><p>Return a set of missing tags. The first element of each couple is the language code, then the tag.</p></dd></dl><dl><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type</span> state</code></dt><dd><p>This type stores all the informations returned by <code>parse</code>.</p></dd></dl><dl><dt class="spec value" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : <a href="index.html#type-intermediary">intermediary</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a></code></dt><dd><p>Once each file have been parsed and put into a single <code>intermediary</code> result, one can treat the full data and produce a final state. This function might throw any of the exceptions defined in this file.</p></dd></dl><dl><dt class="spec value" id="val-elements"><a href="#val-elements" class="anchor"></a><code><span class="keyword">val</span> elements : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <span><span>(Libutils.Id.t, <a href="../Element/index.html#type-t">Element.t</a>)</span> PMap.t</span></code></dt><dd><p>This map stores the identifiers of each element.</p></dd></dl><dl><dt class="spec value" id="val-get_element_name"><a href="#val-get_element_name" class="anchor"></a><code><span class="keyword">val</span> get_element_name : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> Libutils.Id.t <span>&#45;&gt;</span> <span>string option</span></code></dt><dd><p>Given an element identifier, returns its name.</p></dd></dl><dl><dt class="spec value" id="val-get_all_elements"><a href="#val-get_all_elements" class="anchor"></a><code><span class="keyword">val</span> get_all_elements : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../Translation/index.html#type-language">Translation.language</a> <span>&#45;&gt;</span> <span>Libutils.Id.t Libutils.PSet.t</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>Libutils.Id.t list</span></code></dt><dd><p>Return all defined elements in this state that are compatible with the provided language, the chosen set of categories (given as identifiers) and at most this number of players.</p></dd></dl><dl><dt class="spec value" id="val-all_categories"><a href="#val-all_categories" class="anchor"></a><code><span class="keyword">val</span> all_categories : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <span>Libutils.Id.t list</span></code></dt><dd><p>Once the state has been built, categories can be listed.</p></dd></dl><dl><dt class="spec value" id="val-total_number_of_elements"><a href="#val-total_number_of_elements" class="anchor"></a><code><span class="keyword">val</span> total_number_of_elements : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the number of elements defined in the state.</p></dd></dl><dl><dt class="spec value" id="val-number_of_elements"><a href="#val-number_of_elements" class="anchor"></a><code><span class="keyword">val</span> number_of_elements : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../Translation/index.html#type-language">Translation.language</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the number of elements available for a particular language.</p></dd></dl><dl><dt class="spec value" id="val-get_category_dependencies"><a href="#val-get_category_dependencies" class="anchor"></a><code><span class="keyword">val</span> get_category_dependencies : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> Libutils.Id.t <span>&#45;&gt;</span> <span>Libutils.Id.t Libutils.PSet.t</span></code></dt><dd><p>Takes a category identifier and returns the list of categories that this category depends on.</p></dd></dl><dl><dt class="spec value" id="val-get_attribute_dependencies"><a href="#val-get_attribute_dependencies" class="anchor"></a><code><span class="keyword">val</span> get_attribute_dependencies : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../Attribute/index.html#type-attribute">Attribute.attribute</a> <span>&#45;&gt;</span> <span>Libutils.Id.t Libutils.PSet.t</span></code></dt><dd><p>Takes an attribute and returns the list of categories that this attribute depends on.</p></dd></dl><dl><dt class="spec value" id="val-get_constructor_dependencies"><a href="#val-get_constructor_dependencies" class="anchor"></a><code><span class="keyword">val</span> get_constructor_dependencies : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../Attribute/index.html#type-constructor">Attribute.constructor</a> <span>&#45;&gt;</span> <span>Libutils.Id.t Libutils.PSet.t</span></code></dt><dd><p>Takes a constructor and returns the list of categories that this constructor depends on.</p></dd></dl><dl><dt class="spec value" id="val-get_element_dependencies"><a href="#val-get_element_dependencies" class="anchor"></a><code><span class="keyword">val</span> get_element_dependencies : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> Libutils.Id.t <span>&#45;&gt;</span> <span>Libutils.Id.t Libutils.PSet.t</span></code></dt><dd><p>Takes an element identifier and returns the list of categories that this element depends on.</p></dd></dl><dl><dt class="spec value" id="val-get_translations"><a href="#val-get_translations" class="anchor"></a><code><span class="keyword">val</span> get_translations : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../Translation/index.html#type-element">Translation.element</a></code></dt><dd><p>Return the translations for elements.</p></dd></dl><dl><dt class="spec value" id="val-get_constructor_maps"><a href="#val-get_constructor_maps" class="anchor"></a><code><span class="keyword">val</span> get_constructor_maps : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../Attribute/index.html#type-constructor_maps">Attribute.constructor_maps</a></code></dt><dd><p>Return the constructor maps generated while loading the files.</p></dd></dl><dl><dt class="spec type" id="type-import_information"><a href="#type-import_information" class="anchor"></a><code><span class="keyword">type</span> import_information</code><code> = </code><code>{</code><table class="record"><tr id="type-import_information.constructor_maps" class="anchored"><td class="def field"><a href="#type-import_information.constructor_maps" class="anchor"></a><code>constructor_maps : <a href="../Attribute/index.html#type-constructor_maps">Attribute.constructor_maps</a>;</code></td><td class="doc"><p>Information about constructors.</p></td></tr><tr id="type-import_information.event_id" class="anchored"><td class="def field"><a href="#type-import_information.event_id" class="anchor"></a><code>event_id : <span><span>(string, Libutils.Id.t)</span> PMap.t</span>;</code></td><td class="doc"><p>A unique identifier for each event.</p></td></tr><tr id="type-import_information.event_informations" class="anchored"><td class="def field"><a href="#type-import_information.event_informations" class="anchor"></a><code>event_informations : <span><span>(Libutils.Id.t, bool * bool * <span>int <a href="../Events/index.html#type-translation">Events.translation</a></span>)</span> PMap.t</span>;</code></td><td class="doc"><p>Information for each event, organised over event names. In particular:</p><ul><li>whether it is a phantom event,</li><li>whether it is a blocking event,</li><li>how it is translated.</li></ul></td></tr><tr id="type-import_information.event_kinds" class="anchored"><td class="def field"><a href="#type-import_information.event_kinds" class="anchor"></a><code>event_kinds : <span><span>(Libutils.Id.t, <span><span>(int, <span><span>int <a href="../Events/index.html#type-kind">Events.kind</a></span> Libutils.PSet.t</span>)</span> PMap.t</span>)</span> PMap.t</span>;</code></td><td class="doc"><p>The kind associated to each event, organised over event names.</p></td></tr></table><code>}</code></dt><dd><p>Necessary information to import a state.</p></dd></dl><dl><dt class="spec value" id="val-get_import_information"><a href="#val-get_import_information" class="anchor"></a><code><span class="keyword">val</span> get_import_information : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-import_information">import_information</a></code></dt><dd><p>Return information for importation.</p></dd></dl></div></body></html>